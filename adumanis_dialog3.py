# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AdumanisDialog
                                 A QGIS plugin
 adumanis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-02-23
        git sha              : $Format:%H$
        copyright            : (C) 2023 by putusatwika
        email                : putusatwika@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt import QtWidgets, QtGui
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDialog
from qgis.core import QgsProject, Qgis, QgsFeatureSink, QgsMultiPolygon, QgsVectorLayer, QgsField, QgsWkbTypes, QgsGeometry, QgsFeature, QgsPointXY
# from qgis.core import *

from PyQt5.QtCore import QThread
from console import console

import pandas as pd
import numpy as np
import sys
import math
import time
import os
import processing
import webbrowser

from .adumanis_lib import Euclidean
from .adumanis_lib import nodeEvaluation
from .adumanis_lib import closestControl


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .adumanis_dialog_ui import Ui_adumanisDialogBase as Ui_Dialog

import os.path

from processing.core.Processing import Processing

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'adumanis_dialog_base.ui'))


class AdumanisDialog3(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(AdumanisDialog3, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        n = 100
        self.iface = iface
        Processing.initialize()
        self.setupUi(self)
        self.progressBar.setMinimum(0)
        self.progressBar.setMaximum(n)
        self.pushButton.setEnabled(False)
        self.buttonBox.accepted.connect(self.bar)
        self.buttonBox.accepted.connect(self.proses)
        self.buttonBox.accepted.connect(self.reject)
        self.buttonBox.rejected.connect(self.reject)
        self.lineEdit1.setText("adumanis_")

        layers = QgsProject.instance().layerTreeRoot().children()
        self.block.clear()
        self.control.clear()
        self.block.addItems([layer.name() for layer in layers])
        self.control.addItems([layer.name() for layer in layers])

    def bar(self):
        for i in range(5):
            time.sleep(0.01)
            self.progressBar.setValue(i+1)
            self.pushButton.setEnabled(True)
            self.pushButton.clicked.connect(self.cancelProses)
        self.pushButton.setEnabled(False)
        self.progressBar.setValue(0)

    def cancelProses(self):
        self.progressBar.reset()

    def proses(self):
        layers = QgsProject.instance().layerTreeRoot().children()
        dataRawPersil = []
        blockIndex = self.block.currentIndex()
        selectedLayer = layers[blockIndex].layer()
        blockCRS = selectedLayer.crs().authid()
        filename = self.block.currentText()
        for data in selectedLayer.getFeatures():
            persil = data.geometry().asMultiPolygon()[0][0]
            vertex = []
            for i in range(len(persil)):
                vertex.append([round(persil[i].x(),4), round(persil[i].y(),4)])
            dataRawPersil.append(vertex)
        
                
        # ## 2 
        # ## READ CONTROL FILE
        controlIndex = self.control.currentIndex()
        controlLayer = layers[controlIndex].layer()
        controlCoordinates = []
        for fetchData in controlLayer.getFeatures():
            tmp = fetchData.geometry()
            # tmp type <class 'qgis._core.QgsGeometry'> 
            # convert to point <QgsGeometry: Point (x,y)>
            controlCoordinates.append([tmp.asPoint().x(), tmp.asPoint().y()])

        stringPoint = []
        controlPoint = []
        for i in range (len(controlCoordinates)):
            stringCoor= str(controlCoordinates[i][0])+"-"+str(controlCoordinates[i][1])
            if not (stringCoor in stringPoint):
                stringPoint.append(stringCoor)
                controlPoint.append(controlCoordinates[i])
        

        # ## 3
        # ## PARSE BLOCK FILE COORDINATE TO PANDAS
        # ## save as dataframe pandas
        dataPersils = []
        numParcels = len (dataRawPersil)
        totalPoint = 0
        pointParcelControl = 0
        numNonControlPoint = 0

        boundMinX= dataRawPersil[0][0][0]
        boundMinY= dataRawPersil[0][0][1]
        boundMaxX= dataRawPersil[0][0][0]
        boundMaxY= dataRawPersil[0][0][1]

        for p in range (numParcels):
            parcelCoordinate = dataRawPersil[p]
            vertexCoordinate = pd.DataFrame({
                "parcel": [],
                'x': [],
                'y': [],
                'node': [],
                'control': [],
                'isGrouped': []
            })
            for q in range(len(parcelCoordinate)-1):
                controlStatus = 0
                totalPoint = totalPoint +1

                coorX = parcelCoordinate[q][0]
                coorY = parcelCoordinate[q][1]
                ## bounding block
                if (coorX > boundMaxX):
                    boundMaxX = coorX
                if (coorX < boundMinX):
                    boundMinX = coorX
                if (coorY > boundMaxY):
                    boundMaxY = coorY
                if (coorY < boundMinY):
                    boundMinY = coorY

                stringCoor= str(coorX)+"-"+str(coorY)
                if (stringCoor in stringPoint):
                    controlStatus = 1
                    pointParcelControl = pointParcelControl+1
                else:
                    numNonControlPoint = numNonControlPoint + 1
                vertexCoordinate.loc[q] = [p,coorX, coorY, 0, controlStatus, 0]
            dataPersils.append(vertexCoordinate)
        
        # ## 3.1 
        # ## CONTROL EVALUATION, 
        # ## just make sure to used control in bound for fastest process
        # ## find control point in bound -> controlPointBound
        boundMinX = boundMinX - 10
        boundMaxX = boundMaxX + 10
        boundMinY = boundMinY - 10
        boundMaxY = boundMaxY + 10
        controlPointBound = []
        for i in range(len(controlPoint)):
            x = controlPoint[i][0]
            y = controlPoint[i][1]
            if (x > boundMinX and x < boundMaxX and y > boundMinY and y < boundMaxY):
                controlPointBound.append([x,y])
                # print (x,y)

        # ## 4
        # ## NODE EVALUATION
        # ## just used node and eliminates other vertex
        dataNode = []
        numNonControlNode = 0
        for p in range (numParcels):
            nodeCoordinate = pd.DataFrame({
                "parcel": [],
                'x': [],
                'y': [],
                'node': [],
                'control': [],
                'isGrouped': [],
                'group': []
            })
            lenPoint = len(dataPersils[p])
            for q in range(lenPoint):
                currPoint = [dataPersils[p].loc[q,"x"], dataPersils[p].loc[q,"y"]]
                controlStatus = dataPersils[p].loc[q,'control']
                if q == 0:
                    prevPoint = [dataPersils[p].loc[lenPoint-1,"x"],dataPersils[p].loc[lenPoint-1,"y"]]
                    nextPoint = [dataPersils[p].loc[q+1,"x"],dataPersils[p].loc[q+1,"y"]]
                elif q == (lenPoint -1):
                    prevPoint = [dataPersils[p].loc[q-1,"x"],dataPersils[p].loc[q-1,"y"]]
                    nextPoint = [dataPersils[p].loc[0,"x"],dataPersils[p].loc[0,"y"]]
                else:
                    prevPoint = [dataPersils[p].loc[q-1,"x"],dataPersils[p].loc[q-1,"y"]]
                    nextPoint = [dataPersils[p].loc[q+1,"x"],dataPersils[p].loc[q+1,"y"]]
                if(nodeEvaluation(prevPoint, nextPoint, currPoint)):
                    dataPersils[p].loc[q, "node"] = 1
                    ## Abaikan titik kontrol pada bidang
                    nodeCoordinate.loc[q] = [p, currPoint[0], currPoint[1], 1, 0, 0, 0]
                    # nodeCoordinate.loc[q] = [p, currPoint[0], currPoint[1], 1, controlStatus, 0, 0]
                    if controlStatus == 0:
                        numNonControlNode = numNonControlNode+1
            nodeCoordinate.reset_index(inplace=True) ## reset index without delete real index
            dataNode.append(nodeCoordinate)

        # ## 5 
        # ## FINDING PARAMETER
        ## # Finding Parameter
        ## num parcel, all node are control
        numNodeParcel = len(dataNode)
        numNodeParcelControl = 0
        ## Untuk membuat urutan index node parcel
        sequenceParcel = []
        for i in range (numNodeParcel):
            numPoint = len(dataNode[i].index)
            numControl = dataNode[i]['control'].sum()
            if (numPoint == numControl):
                numNodeParcelControl = numNodeParcelControl+1
            else:
                sequenceParcel.append(dataNode[i].loc[0,'parcel'])

        ## Convert controlPoint to dataNode to evaluate in Tie Point
        for p in range(len(controlPointBound)):
            nodeCoordinate = pd.DataFrame({
                'index': [],
                "parcel": [],
                'x': [],
                'y': [],
                'node': [],
                'control': [],
                'isGrouped': [],
                'group': []
            })
            nodeCoordinate.loc[0] = [p, 'point', controlPointBound[p][0], controlPointBound[p][1], 1, 1, 0, 0]
            dataNode.append(nodeCoordinate)

        # ## 6
        # ## TIE POINT CREATOR
        # Create tie point for every control point for initialization
        tollerance = self.doubleSpinBox.value()

        tieGroups = []
        tieGroups.clear()

        groupIdx = 0
        for persilA in range (len(dataNode)):
            pointA = dataNode[persilA]
            for i in range (len(pointA.index)):
                tiePoint = pd.DataFrame(
                    {
                        'parcel': [],
                        'idx': [],
                        'x': [],
                        'y': [],
                        'node': [],
                        'control': [],
                        'group': []        
                    }
                )
                minX = pointA.loc[i,'x'] - tollerance
                minY = pointA.loc[i,'y'] - tollerance
                maxX = pointA.loc[i,'x'] + tollerance
                maxY = pointA.loc[i,'y'] + tollerance
                
                indexTie = 0
                for persilB in range (persilA+1, len(dataNode)):
                    pointB = dataNode[persilB]
                    for j in range(len(pointB.index)):
                        xB = pointB.loc[j, "x"]
                        yB = pointB.loc[j, "y"]
                        if (xB >= minX and xB <= maxX):
                            if (yB > minY and yB <= maxY):
                                # print (persilA,i,"-", persilB,j, "-", groupIdx)
                                tiePoint.loc[indexTie] = [pointB.loc[j, 'parcel'], pointB.loc[j,'index'], pointB.loc[j,'x'], pointB.loc[j,'y'], pointB.loc[j,'node'], pointB.loc[j,'control'], groupIdx]
                                indexTie = indexTie+1               
                tiePoint.loc[indexTie] = [pointA.loc[i, 'parcel'], pointA.loc[i,'index'], pointA.loc[i,'x'], pointA.loc[i,'y'], pointA.loc[i,'node'], pointA.loc[i,'control'], groupIdx]
                tieGroups.append(tiePoint)
                groupIdx = groupIdx +1                    

        # print ("Raw Tie Group Terbentuk:",len(tieGroups))
        # for i in range (len(tieGroups)):
        #     print (tieGroups[i])

        ## MERGING TIE GROUPS
        cleanTieGroups = []
        tieIdxMerge = []
        aloneNode = []
        for i in range (len(tieGroups)-1):
            if i not in tieIdxMerge:
                theMerge = tieGroups[i]
                for idxI in range (len(tieGroups[i].index)): 
                    mergeStatus = 0
                    for j in range (i+1, len(tieGroups)):
                        if (j not in tieIdxMerge):
                            for idxJ in range(len(tieGroups[j].index)):
                                if tieGroups[i].loc[idxI,'parcel'] != 'point' or tieGroups[j].loc[idxJ,'parcel']!='point':
                                    if tieGroups[i].loc[idxI,'parcel'] == tieGroups[j].loc[idxJ,'parcel'] and tieGroups[i].loc[idxI,'idx'] == tieGroups[j].loc[idxJ,'idx']:
                                        theMerge = pd.concat([theMerge, tieGroups[j]], ignore_index = True)
                                        tieIdxMerge.append(j)
                                        mergeStatus = 1
                                if mergeStatus == 1:
                                    break    
                
                if (len(theMerge.index)>1):   
                    ## CLEANING MERGE
                    theCleanMerge = theMerge.drop_duplicates(subset=['parcel', 'idx'], ignore_index=True)
                    cleanTieGroups.append(theCleanMerge)
                elif(len(theMerge.index)==1):
                    aloneNode.append(theMerge)

        # print ("Tie Group Terbentuk:",len(cleanTieGroups))
        # for i in range (len(cleanTieGroups)):
        #     print (cleanTieGroups[i])

        ## # FIND TOTAL NODE NON CONTROL IN TIE POINT
        numTiePointWithControl = 0
        numNonControlNodeinTie = 0
        for i in range (len(cleanTieGroups)):
            temp = len(cleanTieGroups[i].index) - cleanTieGroups[i]['control'].sum()
            numNonControlNodeinTie = numNonControlNodeinTie + temp
            if (cleanTieGroups[i]['control'].sum() > 0):
                numTiePointWithControl = numTiePointWithControl + 1


        # ## 7
        # ## PARAMETER GENERATOR
        numTiePointNoControl = len(cleanTieGroups) - numTiePointWithControl
        numObs = int(numNonControlNodeinTie * 2)
        numParam = (4* (numNodeParcel - numNodeParcelControl)) + (2 * numTiePointNoControl)

        
        
        # ## CHECK POINT
        # ## Check point 1- 6
        print ("Total vertex/node pada block: ", totalPoint)
        print ("Jumlah titik kontrol pada Bidang: ", pointParcelControl)
        print ("Jumlah vertex/node bukan kontrol: ", numNonControlPoint)
        print ("Jumlah NODE bukan kontrol: ", numNonControlNode)
        print ("Jumlah seluruh parcel: ", numParcels)
        print ("Jumlah parcel (Node): ", numNodeParcel)
        print ("Jumlah parcel (Node) kontrol: ", numNodeParcelControl)
        if (numNodeParcelControl == 0):
            print("Warning! Seluruh titik pada bidang dijadiakn pengamatan/observasi")
        print ("Jumlah tie point terbentuk: ", len(cleanTieGroups))
        print ("Jumlah tie point dengan kontrol: ", numTiePointWithControl)
        print ("Jumlah Node berpasangan ", numNonControlNodeinTie)
        print ("Jumlah Observasi: ", numObs)
        print ("Jumlah Parameter: ", numParam)
        # for i in range(len(dataNode)):
        #     print (dataNode[i])

        
        # ## 8.
        # ## MATRIX CREATOR
        # ## pembuatan matrix
        if numParam > numObs:
            print ("Tidak bisa dilanjutkan, parameter lebih banyak  atau sama dengan titik yang diobservasi")
            print ("Parameter: ", numParam, " Observasi: ", numObs)
            msg = str("Tidak bisa dilanjutkan, parameter lebih banyak  atau sama dengan titik yang diobservasi")
            self.iface.messageBar().pushMessage("Adumanis", msg, level=Qgis.Warning, duration=5)
            del dataRawPersil
            del vertex
            del controlCoordinates
            del stringPoint 
            del controlPoint 
            del dataPersils
            del controlPointBound
            del dataNode
            del sequenceParcel
            del tieGroups
            del cleanTieGroups 
            del tieIdxMerge 
            return False
            

        matrixA = np.zeros((numObs, numParam))
        matrixF = np.zeros((numObs,1))

        row = -1
        col = -1
        colPersilStart = numTiePointNoControl*2

        for (i, tie) in enumerate (cleanTieGroups):
            # print (tie)
            tieWithControl = tie['control'].sum()
            if (tieWithControl == 0):
                col = col +1
            for j in range(len(tie.index)):
                point = tie.loc[j]
                # print (point['parcel'], point['idx'])
                if (point.loc['control'] == 0): # not a control
                    row = row +1
                    idxPersil = sequenceParcel.index(point['parcel'])
                    matrixA[2*row, colPersilStart + 4*idxPersil] = point['x']
                    matrixA[2*row, colPersilStart + 4*idxPersil +1] = point['y'] * -1
                    matrixA[2*row, colPersilStart + 4*idxPersil +2] = 1
                    matrixA[2*row, colPersilStart + 4*idxPersil +3] = 0

                    matrixA[2*row +1, colPersilStart + 4*idxPersil] = point['y']
                    matrixA[2*row +1, colPersilStart + 4*idxPersil +1] = point['x']
                    matrixA[2*row +1, colPersilStart + 4*idxPersil +2] = 0
                    matrixA[2*row +1, colPersilStart + 4*idxPersil +3] = 1
                
                    if (tieWithControl):
                        [x,y] = closestControl(tie, point)
                        # print (x, y)
                        matrixF[2*row, 0] = x
                        matrixF[2*row+1, 0] = y
                    else:
                        matrixA[2*row, 2*col] = -1
                        matrixA[2*row+1, 2*col+1] = -1

        # ## # DEBUG
        # ## # EXPORT MATRIX TO EXCEL
        # da = pd.DataFrame(matrixA)
        # df = pd.DataFrame(matrixF)
        # with pd.ExcelWriter("MatrixAF.xlsx") as writer:
        #     da.to_excel(writer, sheet_name='MatrixA')
        #     df.to_excel(writer, sheet_name='MatrixF')

        # ## 9.
        # ## SOLVE THE MATRIX CALCULATION
        # ## solve the matrix with least square algorithm
        At = np.transpose(matrixA)
        AtA = np.dot(np.mat(At), np.mat(matrixA))
        AtF = np.dot(np.mat(At), np.mat(matrixF))

        matrixX = np.linalg.solve(AtA, AtF)

        V = np.dot(np.mat(matrixA), np.mat(matrixX)) - np.mat(matrixF)
        # print("Matriks Residu = ", V)

        dof = (numObs - numParam)
        Var = np.dot(np.transpose(V), np.mat(V)) / dof
        print("Variansi A-posteriori = ", Var.item())

        Qxx = np.linalg.inv(AtA)
        Sxx = abs(Var.item() * Qxx)

        ## #find standar deviation of Sxx.
        SdSxx = []
        for i in range(len(Sxx)):
            data = math.sqrt(Sxx[i,i])
            SdSxx.append(data)

        # # EXPORT MATRIX TO EXCEL
        # da = pd.DataFrame(Qxx)
        # df = pd.DataFrame(Sxx)
        # dsx = pd.DataFrame(np.mat(SdSxx))
        # dx = pd.DataFrame(matrixX)

        # with pd.ExcelWriter("MatrixQSX.xlsx") as writer:
        #     da.to_excel(writer, sheet_name='Qsxx')
        #     df.to_excel(writer, sheet_name='Sxx')
        #     dsx.to_excel(writer, sheet_name="SdSxx")
        #     dx.to_excel(writer, sheet_name = "MatrixX")

        # ## 10.
        # ## UPDATE TIE POINT
        # update all node in tie Point
        tieNumber = -1
        for (i, tie) in enumerate (cleanTieGroups):
            if tie['control'].sum() == 0:
                tieNumber = tieNumber + 1
                for j in range (len(tie.index)):
                    parcelNum = int(tie.loc[j,'parcel'])
                    index = int (tie.loc[j,'idx'])
                    dataPersils[parcelNum].loc[index,'x'] = matrixX[tieNumber*2]
                    dataPersils[parcelNum].loc[index,'y'] = matrixX[tieNumber*2+1]
            elif tie['control'].sum() > 0:
                for j in range (len(tie.index)):
                    point = tie.loc[j]
                    if (point['control']==0):
                        parcelNum = int(point['parcel'])
                        index = int (point['idx'])
                        [controlX, controlY] = closestControl(tie, point)
                        dataPersils[parcelNum].loc[index,'x'] = controlX
                        dataPersils[parcelNum].loc[index,'y'] = controlY
        
        # ## update all alone node, without tie point
        for i in range (len(aloneNode)):
            if (aloneNode[i].loc[0,'control']==0 and dataNode[i].loc[0,'node']==1):
                parcel = aloneNode[i].loc[0,'parcel']
                if (parcel !='point'):
                    parcelNum = int (parcel)
                    index = int (aloneNode[i].loc[0,'idx'])
                    ##transform based on a,b,c,d in matrix X
                    loc = sequenceParcel.index(parcelNum) * 4
                    a = matrixX[colPersilStart + loc]
                    b = matrixX[colPersilStart + loc + 1]
                    c = matrixX[colPersilStart + loc + 2]
                    d = matrixX[colPersilStart + loc + 3]
                    x = aloneNode[i].loc[0, 'x']
                    y = aloneNode[i].loc[0, 'y']
                    dataPersils[parcelNum].loc[index, 'x'] = a*x - b*y + c
                    dataPersils[parcelNum].loc[index, 'y'] = b*x + a*y + d
        
        # ## 11.
        # ## TRANSFORM NODE/VERTEX
        # ## transform node and vertex to new location after adjustment and error lambda
        for i in range (len(dataPersils)):
            if (i in sequenceParcel):
                ## find a, b, c, d in matrix X
                ## find error parcel
                loc = sequenceParcel.index(i) * 4
                a = matrixX[colPersilStart + loc]
                b = matrixX[colPersilStart + loc + 1]
                c = matrixX[colPersilStart + loc + 2]
                d = matrixX[colPersilStart + loc + 3]
                errorDeltaLambda = (math.sqrt(a*a + b*b)) - 1
                errorParcelPersen = pow((errorDeltaLambda*errorDeltaLambda*100),2)
                print ("ERROR parcel index: ", i, " is: ", errorParcelPersen)
                ## transform all vertex 
                for j in range (len(dataPersils[i].index)):
                    if (dataPersils[i].loc[j,'control'] == 0):
                        if (dataPersils[i].loc[j,'node']==0):
                            dataPersils[i].loc[j,'x'] = a*dataPersils[i].loc[j,'x'] - b*dataPersils[i].loc[j,'y'] + c
                            dataPersils[i].loc[j,'y'] = b*dataPersils[i].loc[j,'x'] + a*dataPersils[i].loc[j,'y'] + d
        # print (dataPersils)



        # ## 12.
        # ## OUT/SAVE RESULT
        # ## create persil result after calculation
        # print ("WKBTYPE:",selectedLayer.wkbType())
        # print ("QGISmultipoly: ", QgsWkbTypes.MultiPolygon)
        nama_layer_valid = str(self.lineEdit1.text())
        
        uri ="MultiPolygon?crs="+blockCRS
        outputLayer = QgsVectorLayer(uri, nama_layer_valid, "memory")
        outputLayer.dataProvider().addAttributes([
            QgsField('id', QVariant.Int), 
            QgsField('persil_name', QVariant.String)])
        outputLayer.updateFields()

        # SAMPLE IF YOU WANT TO CREATE POINT
        # features = []
        # for i in range(10):
        #     point = QgsGeometry.fromPointXY(QgsPointXY(i, i))
        #     feature = QgsFeature()
        #     feature.setGeometry(point)
        #     feature.setAttributes([i, i * 2])
        #     features.append(feature)
        # outputLayer.dataProvider().addFeatures(features)
        # outputLayer.updateExtents()

        # polygon_points = [
        #     [[327403.28, 735126.43],[327415.28, 735126.43],[327415.28, 735142.43],[327403.28, 735142.43]],
        #     [[327393.28, 735116.43],[327405.28, 735116.43],[327405.28, 735132.43],[327393.28, 735132.43]]
        #     ]

        ## ---BEGIN ADD TO LAYER
        # polygon_points = []
        # for i in range (len(dataPersils)):
        #     coordinatePoints = []
        #     for j in range(len(dataPersils[i].index)):
        #         temp = (dataPersils[i].loc[j,'x'], dataPersils[i].loc[j,'y'])
        #         coordinatePoints.append(temp)
        #     ## apend to begining point
        #     coordinatePoints.append((dataPersils[i].loc[0,'x'], dataPersils[i].loc[0,'y']))
        #     polygon_points.append(coordinatePoints)
        
        # feature = QgsFeature()
        # parcel = [[[QgsPointXY(point[0],point[1]) for point in polygon ] for polygon in polygon_points ]]
        # feature.setGeometry(QgsGeometry.fromMultiPolygonXY(parcel))
        # feature.setAttributes([1, 'My Multipolygon'])

        # Add feature to layer
        # outputLayer.startEditing()
        # outputLayer.addFeature(feature)
        # outputLayer.commitChanges()
        ## --- END ADD TO LAYER


        
        outputLayer.startEditing()
        for i in range (len(dataPersils)):
            feature = QgsFeature()
            coordinatePoints = []
            pointtoAdd = []
            for j in range(len(dataPersils[i].index)):
                temp = (dataPersils[i].loc[j,'x'], dataPersils[i].loc[j,'y'])
                coordinatePoints.append(temp)
            ## apend to begining point
            coordinatePoints.append((dataPersils[i].loc[0,'x'], dataPersils[i].loc[0,'y']))
            pointtoAdd.append(coordinatePoints)
            parcel = [[[QgsPointXY(point[0],point[1]) for point in polygon ] for polygon in pointtoAdd ]]
            feature.setGeometry(QgsGeometry.fromMultiPolygonXY(parcel))
            feature.setAttributes([i, 'Parcel'+str(i)])
            outputLayer.addFeature(feature)
        outputLayer.commitChanges()

        # Add layer to the project and map view
        QgsProject.instance().addMapLayer(outputLayer)

        ## FLUSH VARIABLE
        # initializing d with dir()
        # This will store a list of all the variables in the program
        del dataRawPersil
        del vertex
        del controlCoordinates
        del stringPoint 
        del controlPoint 
        del dataPersils
        del controlPointBound
        del dataNode
        del sequenceParcel
        del tieGroups
        del cleanTieGroups 
        del tieIdxMerge 
        del aloneNode 
        del SdSxx

        # ## MESSAGE OUT:
        msg = str("Proses Adumanis telah selesai!")
        self.iface.messageBar().pushMessage("Adumanis", msg, level=Qgis.Success)
        layers = QgsProject.instance().layerTreeRoot().children()
        self.block.clear()
        self.control.clear()
        self.block.addItems([layer.name() for layer in layers])
        self.control.addItems([layer.name() for layer in layers])